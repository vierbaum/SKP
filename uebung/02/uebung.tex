\documentclass{article}
\usepackage{tikz}
\usepackage{pgfplots}
\usepackage{amsmath, amsfonts}
\usepackage{enumerate}
\usepackage{pdfpages}
\usepackage{listings}
\usetikzlibrary{shapes,arrows,fit,calc,positioning}
\usepackage{pgffor}
\input{title.tex}
\def\first#1,#2,#3\relax{#1}
\def\second#1,#2,#3\relax{#2}
\def\third#1,#2,#3\relax{#3}

\newcommand{\N}{\mathbb{N}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\E}{\mathbb{E}}
\newcommand{\V}{\mathbb{V}}
\renewcommand{\P}{\mathbb{P}}
\begin{document}
    \maketitle
    \section{}
    Siehe zip
    \section{}
    \begin{enumerate}[a)]
        \item
            \begin{enumerate}[i.]
                \item
                    \begin{tabular}{|l|c|}
                        \hline
                        Schritt:&\\
                        \hline
                        \hline
                        Prozessor führt i-ten Befehl des Benutzerprogramms aus. Währenddes-&a\\
                        sen wird ein Interrupt an den UBR-Controller gemeldet. Der UBR-&\\
                        Controller legt das entsprechende Unterbrechungssignal an den Prozes-&\\
                        sor an.&\\
                        \hline
                        Prozessor führt den i-ten Befehl zu Ende aus.&d\\
                        \hline
                        Prozessor überprüft, ob ein Unterbrechungssignal vom UBR-Controller&f\\
                        vorliegt.&\\
                        \hline
                        Prozessor unterbricht Ausführung des Benutzerprogramms und beginnt&e\\
                        Unterbrechungsbehandlung. Der Prozessor signalisiert dies dem UBR-&\\
                        Controller. Der Zustand des Benutzerprogramms wird gesichert.&\\
                        \hline
                        Prozessor lädt neuen Befehl entsprechend der Unterbrechungsvektorta-&g\\
                        belle.&\\
                        \hline
                        Prozessor führt Unterbrechungsroutine aus. Die Unterbrechungsroutine&b\\
                        wird ausgeführt. Dann wird die Unterbrechungsroutine verlassen.&\\
                        \hline
                        Der Zustand des Benutzerprogramms wird wiederhergestellt.&c\\
                        \hline
                        Prozessor lädt den (i+1)-ten Befehl des Benutzerprogramms und führt&h\\
                        diesen aus.&\\
                        \hline
                    \end{tabular}
                \item
                    \begin{tabular}{|l|c|}
                        \hline
                        Schritt:&\\
                        \hline
                        \hline
                        Prozessor führt den i-ten Befehl zu Ende aus.&d\\
                        \hline
                        Prozessor überprüft, ob ein Unterbrechungssignal vom UBR-Controller&f\\
                        vorliegt.&\\
                        \hline
                        Prozessor lädt den (i+1)-ten Befehl des Benutzerprogramms und führt&h\\
                        diesen aus.&\\
                        \hline
                    \end{tabular}
            \end{enumerate}
        \item
            \begin{tabular}{|c|c|c|}
                \hline
                &In PCB enthalten&Nicht in PCB enthalten\\
                \hline
                \hline
                Prozessidentität (pid)&$\times$&\\
                \hline
                Maschinencode des Programms&&$\times$\\
                \hline
                Programmcounter, bzw. Befehlszeiger&$\times$&\\
                \hline
                Kopie der Systemlibrary&&$\times$\\
                \hline
                Globale Variablen des Prozesses&&$\times$\\
                \hline
                Zeiger auf Prozessspeicherbereiche&$\times$&\\
                \hline
            \end{tabular}
        \item
            Wir haben N(eu), Be(reit), A(ktiv), Bl(ockiert), T(erminiert)\\
            \begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|}
                \hline
                \textbf{Prozess}&$t_0$&$t_1$&$t_2$&$t_3$&$t_4$&$t_5$&$t_6$&$t_7$&$t_8$&$t_9$\\
                \hline
                p&N&A&Bl&Bl&A&Be&A&T&T&T\\
                \hline
                q&N&Be&A&Be&Be&A&Bl&A&T&T\\
                \hline
                r&N&Be&Be&A&Bl&Bl&Be&Be&A&T\\
                \hline
            \end{tabular}
    \end{enumerate}
    \newpage
    \section{}
    \begin{enumerate}[a)]
        \item
            Wir nehmen an, dass es ein Zeitintervall, der Größe $x$ gibt, in dem
            die Funktion \verb|switch| immer mindestens einmal aufgerufen.
            Nun sei der einfachheit halber $p_1$\verb|.td_total|$:=0$ und
            $p_2$\verb|.td_total|$:=y\leq nx$.
            In jedem, der ersten $k:=n-1$ Zeitintervallen wird switch aufgerufen
            und verläuft folgendermaßen:
            \begin{lstlisting}[mathescape=true]
                procedure SWITCH()
                    p=$p_1$
                    if ((p nicht mehr ausfuehrbereit; false) und
                        (nicht terminiert; true); false) then
                        skip
                    else
                        enqueue(p) {
                        procedure ENQUEUE(p)
                            if (p ist terminiert; false) then
                                skip
                            else
                                $p_1$.td_total = (k-1)x + x = kx
                            end if
                            return
                        }
                    end if
                    q = dequeue() = $p_1$
                    fuehre q aus
                    return
            \end{lstlisting}
            beim durchlauf $n$ wiederrum ist
            $p_1$.\verb|td_total|$=nx$
            und in \verb|dequeue|
            wird somit $p_2$ ausgeführt, da
            $p_2$.\verb|td_total|$=y<$
            $nx=p_1$.\verb|td_total|.
            Dies ist aber nur der Fall, solange $p_2$ auch wirklich
            bereit ist.
            Somit kann ein prozess $p_2$, der immer bereit ist,
            nicht verhungern.
        \item
            Je nach implementation von ``aufräumen'' (ENQUEUE) kann es dazu kommen,
            dass \verb|td_total| bereits beim Terminieren des Prozesses
            gelöscht wird.
            \begin{tikzpicture}[xscale=1,transform shape]
                \draw [dashed] (.25, -.2) -- (.25, -4.2);
                \foreach \t in {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25} {
                    \draw (\t / 2, 0) node {\t};
                    \draw [dashed] (\t / 2 + .25, -.2) -- (\t / 2 + .25, -4.2);
                }
                \foreach \y in {-.2, -1.2, -2.2, -3.2, -4.2} {
                    \draw (.25, \y) -- (12.75, \y);
                }

                % A active
                \foreach \x in {1, 9, 10, 20} {
                    \def\coordx{\x / 2 - .25}
                    \draw [fill, white] (\coordx, -.3) rectangle (\coordx+.5, -.6);
                    \draw (\coordx, -.3) rectangle (\coordx+.5, -.6);
                }
                % A blocked
                \foreach \x in {2, 3, 11, 12, 13} {
                    \def\coordx{\x / 2 - .25}
                    \draw [fill, gray] (\coordx, -.3) rectangle (\coordx+.5, -.6);
                }
                % A td_total
                % {idx, len, value}
                \foreach \bar in {{1, 3, 0}, {4, 10, 3}, {14, 12, 8}} {
                    \def\x{\expandafter\first\bar\relax};
                    \def\len{\expandafter\second\bar\relax}
                    \def\val{\expandafter\third\bar\relax}

                    \def\coordx{\x / 2 - .25}
                    \def\y{\coordx + \len / 2}
                    \draw [fill, white] (\coordx, -.7) rectangle (\y, -1);
                    \draw (\coordx, -.7) rectangle (\y, -1);

                    \def\rectx{\coordx + \len / 4}
                    \node at (\rectx, -.85) {\val};
                }

                % B active
                \foreach \x in {2, 3, 4, 21} {
                    \def\coordx{\x / 2 - .25}
                    \draw [fill, white] (\coordx, -1.3) rectangle (\coordx+.5, -1.6);
                    \draw (\coordx, -1.3) rectangle (\coordx+.5, -1.6);
                }
                % B blocked
                \foreach \x in {5,6,7,8,9,10} {
                    \def\coordx{\x / 2 - .25}
                    \draw [fill, gray] (\coordx, -1.3) rectangle (\coordx+.5, -1.6);
                }

                % B td_total
                % {idx, len, value}
                \foreach \bar in {{2, 2, 0}, {4, 7, 2}, {11, 15, 9}} {
                    \def\x{\expandafter\first\bar\relax};
                    \def\len{\expandafter\second\bar\relax}
                    \def\val{\expandafter\third\bar\relax}

                    \def\coordx{\x / 2 - .25}
                    \def\y{\coordx + \len / 2}
                    \draw [fill, white] (\coordx, -1.7) rectangle (\y, -2);
                    \draw (\coordx, -1.7) rectangle (\y, -2);

                    \def\rectx{\coordx + \len / 4}
                    \node at (\rectx, -1.85) {\val};
                }

                % C active
                \foreach \x in {5,6,7,8, 15, 16, 18, 19} {
                    \def\coordx{\x / 2 - .25}
                    \draw [fill, white] (\coordx, -2.3) rectangle (\coordx+.5, -2.6);
                    \draw (\coordx, -2.3) rectangle (\coordx+.5, -2.6);
                }

                % C td_total
                % {idx, len, value}
                \foreach \bar in {{5,2,0}, {7, 2, 2}, {9, 8, 4}, {17, 9, 6}} {
                    \def\x{\expandafter\first\bar\relax};
                    \def\len{\expandafter\second\bar\relax}
                    \def\val{\expandafter\third\bar\relax}

                    \def\coordx{\x / 2 - .25}
                    \def\y{\coordx + \len / 2}
                    \draw [fill, white] (\coordx, -2.7) rectangle (\y, -3);
                    \draw (\coordx, -2.7) rectangle (\y, -3);

                    \def\rectx{\coordx + \len / 4}
                    \node at (\rectx, -2.85) {\val};
                }

                % D active
                \foreach \x in {11, 12, 13, 14, 17} {
                    \def\coordx{\x / 2 - .25}
                    \draw [fill, white] (\coordx, -3.3) rectangle (\coordx+.5, -3.6);
                    \draw (\coordx, -3.3) rectangle (\coordx+.5, -3.6);
                }
                % D blocked
                \foreach \x in {15} {
                    \def\coordx{\x / 2 - .25}
                    \draw [fill, gray] (\coordx, -3.3) rectangle (\coordx+.5, -3.6);
                }

                % D td_total
                % {idx, len, value}
                \foreach \bar in {{10, 3, 0}, {13, 3, 2}, {16, 10, 5}} {
                    \def\x{\expandafter\first\bar\relax};
                    \def\len{\expandafter\second\bar\relax}
                    \def\val{\expandafter\third\bar\relax}

                    \def\coordx{\x / 2 - .25}
                    \def\y{\coordx + \len / 2}
                    \draw [fill, white] (\coordx, -3.7) rectangle (\y, -4);
                    \draw (\coordx, -3.7) rectangle (\y, -4);

                    \def\rectx{\coordx + \len / 4}
                    \node at (\rectx, -3.85) {\val};
                }
            \end{tikzpicture}
            \newpage
        \item
            \begin{enumerate}[i.]
                \item
                    $T=\frac{1+4+14}{3}\approx 6.33$ ZE
                \item
                    Dadurch, dass wir I/O-Phasen jeweils zur Prozesszeit dazurechnen, müssen Prozesse
                    mit langen I/O-Phasen, aber kurzen Rechenzeiten lange warten.
                \item
                    Wir zählen nur noch tatsächliche Prozesszeit.
                    Diese berechnen wir sobald, wir den Prozess wechseln in SWITCH:
                    \begin{lstlisting}
1:  procedure switch( )
2:      p = bis jetzt auf der CPU ausgefuehrter Prozess
+       p.td_total = p.td_total + (now() - p.ti_deq)
3:      if p nicht mehr ausfuehrbereit und nicht terminiert then
4:      fuege p zu BlockedCollection hinzu
5:      else
6:      enqueue(p)
7:      end if
8:      q = dequeue()
9:      setze q als auf dem Prozessor auszufuehrenden Prozess
10: end procedure
                    \end{lstlisting}
            \end{enumerate}
        \item
            \begin{enumerate}[i.]
                \item
                    Es kann dazu kommen, dass die Prozesse, die zu Beginn gestartet werden eine lange
                    \verb|td_total| haben und somit vom Scheduler vernachlässigt werden im vergleich
                    zu neu gestarteten Prozessen, die noch eine Niedrige \verb|td_total| haben.
                    Hierzu kann man aufgabe b) prozesse A bzw C und D vergleichen.
                \item
                Wir nutzen anstelle der gesamten Ausführungszeit die Ausführungszeit pro Laufzeit.
                Somit werden in Enqueue Zeilen 5-7 zu:
                \begin{lstlisting}
5: if p ist neuer Prozess then:
6:    p.td_total = 0
+:    p.t_init = now()
7: else
                \end{lstlisting}
                und Dequeue wird zu:
                \begin{lstlisting}
1: procedure dequeue( )
-: p = Prozess aus ReadyCollection mit niedrigstem Wert fuer p.td_total
+: p = Prozess aus ReadyCollection mit niedrigstem Wert fuer
+:    p.td_total / (now() - p.t_init)
3: p.ti_deq = now()
                \end{lstlisting}
            \end{enumerate}
    \end{enumerate}
    \newpage
    \section{}
    \begin{enumerate}[a)]
        \item
            Nein, das ist nicht garantiert. Es könnte dann nämlich zufälligerweise so sein, dass der Scheduler die
            Prozesse immer so drannimmt, dass man immer in solche Zustände kommt, dass man in einem Zyklus
            landet. Solche Zyklen gibt es hier mehrere, z.B. $(b, c, d, e, f, g, b)$ oder $(c, d, e, f, c)$.
        \item
            Ja, das ist garantiert. Betrachte den Zustand $d$: Hier gibt es 2 ausgehende Kanten, was darauf hinweist,
            dass es mind. 2 ausführungsbereite Befehle gibt. Seien $p_i$ und $q_j$ diese beiden Befehle, wobei die Ausführung
            von $p_i$ zum Zustand $\Omega$ führen würde, und die Ausführung von $q_j$ zu $e$. Durch Widerspruch: Nehmen wir
            an, das Programm würde trotz stark fairer Ausführung nicht terminieren. Dann muss das Programm
            zunächst folgenden Pfad ausführen: $(a, b, c, d)$ und dann unendlich oft Pfade ausführen, die nicht zu $\Omega$
            führen. Die einzige Möglichkeit dafür ist unendlich oft die beiden Zyklen auszuführen, die in a) erwähnt
            wurden. Beide enthalten aber den Zustand $d\Rightarrow$ das Programm kommt unendlich oft in den Zustand $d$
            $\Rightarrow p_i$ ist unendlich oft ausführungsbereit. Da das Programm $p_i$ aber nie ausführt, da es sonst terminieren
            würde, ist hier ein Widerspruch zur starker Fairness: Jeder unendlich oft (nicht notwendigerweise ständig)
            ausführungsbereite Befehl eines Prozesses wird unendlich oft ausgeführt. Also ist die Annahme falsch $\Rightarrow$
            eine stark faire Ausführung des Programms terminiert garantiert.
    \end{enumerate}
\end{document}
